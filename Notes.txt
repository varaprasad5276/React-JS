// Inception
1) what is emmet?
    Emmet is a free plugin for text editors that allows us to write HTML, CSS, and other code formats 
    faster by assisting through abbreviations that expand into full code.

    html:5 enter

2) diiference b/w library and framework
    A library is a collection of pre-written code that can be used to perform specific tasks. 
    A framework is a set of pre-written code that provides a structure for developing software applications.

3) what is CDN? why do we use it?
   A content delivery network (CDN) is a network of interconnected servers that speeds up webpage loading for data-heavy applications. 
   CDN can stand for content delivery network or content distribution network.

4) why react knows as react?
   React is a JavaScript library for building user interfaces. It is known for its speed, scalability, and simplicity.
   React is also known for its component-based architecture, which makes it easy to create reusable and maintainable code.

   The name "React" comes from the way that React components "react" to changes in state. When a component's state changes, 
   React automatically re-renders the component and its child components. 
   This makes it easy to create dynamic and interactive user interfaces.

5) what is crossorigin in script tag?
   The crossorigin attribute sets the mode of the request to an HTTP CORS Request. 
   Web pages often make requests to load resources on other servers. 

6) what is the diiference between React and ReactDOM?
   React is the core library that provides the functionality for creating and managing components, 
   ReactDOM is a separate library that provides DOM-specific methods for rendering React components.

7) what is the diiference between React.development.js  and React.production.js files via CDN?
   The main difference between React.development.js and React.production.js files via CDN is that 
   the development version is used for debugging and development purposes, 
   while the production version is used for production purposes.

===============================================
ep 2- igniting app 
 
 1) what is NPM?
   npm stands for Node Package Manager. It's a library and registry for JavaScript software packages. 
   npm also has command-line tools to help you install the different packages and manage their dependencies.

2) what is parcel/webpack ? why do we need it ?
   Parcel and webpack are the bundlers used mostly for JavaScript or Typescript code 
   that helps you to minify, clean, and make your code compact .
   
   so that it becomes easier to send a request or receive the response from the server 
   when it usually takes you to transfer multiple files without using any bundler for loading the page of your application.

3) what is .parcel-cache
   .parcel-cache` is a directory generated by the Parcel bundler, serving as a cache for storing intermediate build results.

4) what is NPX?
   NPX stands for Node Package eXecute. It is simply an NPM package runner. 
   It allows developers to execute any Javascript Package available on the NPM registry without even installing it.

5) what is difference between dependencies vs devdependencies
   The difference between a dependency and a devDependency is that 
   dependency is needed always both in development and production phase, 
   while devDependency is needed only in the development phase.

6) what is tree shacking? 
   Tree shaking is a technique that removes unused code from a bundle. It's used in JavaScript, Dart, and Typescript.
     
     Tree shaking can: 
        Reduce download size
        Improve performance
        Optimize web performance
        Reduce carbon footprint
        Reduce initial load time

7) what is Hot Module Replacement?
   Hot Module Replacement (HMR) is a Webpack feature that allows for the updating of code in a running application without rebuilding it. 
   HMR can add, remove, or exchange modules while an application is running without a full reload.

8) what is .gitignore ? what should we add and not add into it?
   gitignore file tells Git which files to ignore when committing your project to the GitHub repository. 

   we are adding  /node_modules ,/dist, /.parcel-cache 
   folders to .gitignore because we don't need this to push git,we can recreate this files if we have package.json & package-lock.json files.
   
   we are not adding the package.json & package-lock.json these 2 files to .gitignore,without these files we are unable to receate /node_modules ,/dist, /.parcel-cache .
   
9) what is difference between package.json & package-lock.json?
   package.json
       It is a metadata file that describes the project's dependencies, scripts, configuration, and other details.
   package-lock.json
       It is a lockfile that provides an exact, deterministic list of all the installed packages and their dependencies, including their exact version numbers.

10) why should i not modify package-lock.json?
   You should not modify package-lock.json unless you are updating the required packages.

11) what is node_modules? it is good idea to push that on git?
   The node_modules folder is a folder that is created when you install packages using the Node Package Manager (npm).
    It stores the packages and their dependencies that your project requires.

    It is generally not a good idea to push the node_modules folder to git because it can be very large and can change frequently. 

12) what is dist folder?
   The dist folder in React is a production-ready build of your application. It contains the minified and bundled code,
    as well as any assets that were used in the build process. The dist folder is typically created by running the npm run build command.

    The dist folder is typically used when you are ready to deploy your application to a production server. It is also useful for testing your application in a production-like environment.

 13) what is browserlists read about different bundlers : parcel ,webpack ,vite ?
     Browserslist is a tool that allows developers to specify which browsers they want their web application to support.
      It does this by using a configuration file that lists the browsers and versions that the application needs to support. 
      Browserslist is used by many different tools, including Autoprefixer, Babel, ESLint, PostCSS, SWC, and Webpack.

   Parcel is a web application bundler that is fast and easy to use. It does not require a configuration file, and 
   it can bundle JavaScript, CSS, and HTML files. Parcel also supports hot reloading, which makes it easy to develop and 
   debug web applications.

   Webpack is a module bundler that can be used to bundle JavaScript files for usage in a browser. It is more complex to use than 
   Parcel, but it offers more features and flexibility. Webpack can be used to bundle JavaScript modules, transpile code, 
   and optimize bundles for different browsers.

   Vite is a next-generation frontend tool that provides a lightning-fast dev server, bundling, and resolves the server cold start issue. 
   It is similar to Parcel in that it does not require a configuration file and it can bundle JavaScript, CSS, and HTML files. 
   However, Vite is faster than Parcel and it offers some additional features, such as native HMR support and built-in code splitting.

  14) Caret (^) and Tilde (~)?

     the tilde () allows updates to the patch version of a package, 
     while the caret (^) allows updates to the minor and patch versions of a package, while keeping the major version fixed 

   =========================================
   Episode 3:

1)What is JSX?
A: JSX stands for JavaScript XML. JSX allows us to write HTML elements in JavaScript and place them in the DOM without any createElement() and/or appendChild() methods. JSX makes it easier to write and add HTML in React. JSX converts HTML tags into react elements.

Example 1 using JSX:
const myElement = <h1>I Love JSX!</h1>;
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(myElement);

Example 2 Without JSX:
const myElement = React.createElement('h1', {}, 'I do not use JSX!');
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(myElement);

2) Superpowers of JSX.
A: Using JSX, you can write markup inside Javascript, providing you with a superpower to write logic and markup of a component inside a single .jsx file. JSX is easy to maintain and debug.

Example
function greeting(user) {
//JSX
  return <h1>{user}, How are you!!!</h1>;
}
3) Role of type attribute in script tag? What options can I use there?
A: The type attribute specifies the type of the script. The type attribute identifies the content between the <script> and </script> tags. It has a Default value which is “text/javascript”.

type attribute can be of the following types:
text/javascript : It is the basic standard of writing javascript code inside the <script> tag.

Syntax
<script type="text/javascript"></script>

text/ecmascript : this value indicates that the script is following the EcmaScript standards.
module: This value tells the browser that the script is a module that can import or export other files or modules inside it.
text/babel : This value indicates that the script is a babel type and required bable to transpile it.
text/typescript: As the name suggest the script is written in TypeScript.

4) {TitleComponent} vs {<TitleComponent/>} vs {<TitleComponent></TitleComponent>} in JSX.
A: The Difference is stated below:

{TitleComponent}: This value describes the TitleComponent as a javascript expression or a variable. The {} can embed a javascript expression or a variable inside it.
<TitleComponent/> : This value represents a Component that is basically returning Some JSX value. In simple terms TitleComponent a function that is returning a JSX value. A component is written inside the {<  />} expression.
<TitleComponent></TitleComponent> : <TitleComponent /> and <TitleComponent></TitleComponent> are equivalent only when < TitleComponent /> has no child components. The opening and closing tags are created to include the child components.
Example
<TitleComponent>
    <FirstChildComponent />
    <SecondChildComponent />
    <ThirdChildComponent />
</TitleComponent>
