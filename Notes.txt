// Inception
1) what is emmet?
    Emmet is a free plugin for text editors that allows us to write HTML, CSS, and other code formats 
    faster by assisting through abbreviations that expand into full code.

    html:5 enter

2) diiference b/w library and framework
    A library is a collection of pre-written code that can be used to perform specific tasks. 
    A framework is a set of pre-written code that provides a structure for developing software applications.

3) what is CDN? why do we use it?
   A content delivery network (CDN) is a network of interconnected servers that speeds up webpage loading for data-heavy applications. 
   CDN can stand for content delivery network or content distribution network.

4) why react knows as react?
   React is a JavaScript library for building user interfaces. It is known for its speed, scalability, and simplicity.
   React is also known for its component-based architecture, which makes it easy to create reusable and maintainable code.

   The name "React" comes from the way that React components "react" to changes in state. When a component's state changes, 
   React automatically re-renders the component and its child components. 
   This makes it easy to create dynamic and interactive user interfaces.

5) what is crossorigin in script tag?
   The crossorigin attribute sets the mode of the request to an HTTP CORS Request. 
   Web pages often make requests to load resources on other servers. 

6) what is the diiference between React and ReactDOM?
   React is the core library that provides the functionality for creating and managing components, 
   ReactDOM is a separate library that provides DOM-specific methods for rendering React components.

7) what is the diiference between React.development.js  and React.production.js files via CDN?
   The main difference between React.development.js and React.production.js files via CDN is that 
   the development version is used for debugging and development purposes, 
   while the production version is used for production purposes.

===============================================
ep 2- igniting app 
 
 1) what is NPM?
   npm stands for Node Package Manager. It's a library and registry for JavaScript software packages. 
   npm also has command-line tools to help you install the different packages and manage their dependencies.

2) what is parcel/webpack ? why do we need it ?
   Parcel and webpack are the bundlers used mostly for JavaScript or Typescript code 
   that helps you to minify, clean, and make your code compact .
   
   so that it becomes easier to send a request or receive the response from the server 
   when it usually takes you to transfer multiple files without using any bundler for loading the page of your application.

3) what is .parcel-cache
   .parcel-cache` is a directory generated by the Parcel bundler, serving as a cache for storing intermediate build results.

4) what is NPX?
   NPX stands for Node Package eXecute. It is simply an NPM package runner. 
   It allows developers to execute any Javascript Package available on the NPM registry without even installing it.

5) what is difference between dependencies vs devdependencies
   The difference between a dependency and a devDependency is that 
   dependency is needed always both in development and production phase, 
   while devDependency is needed only in the development phase.

6) what is tree shacking? 
   Tree shaking is a technique that removes unused code from a bundle. It's used in JavaScript, Dart, and Typescript.
     
     Tree shaking can: 
        Reduce download size
        Improve performance
        Optimize web performance
        Reduce carbon footprint
        Reduce initial load time

7) what is Hot Module Replacement?
   Hot Module Replacement (HMR) is a Webpack feature that allows for the updating of code in a running application without rebuilding it. 
   HMR can add, remove, or exchange modules while an application is running without a full reload.

8) what is .gitignore ? what should we add and not add into it?
   gitignore file tells Git which files to ignore when committing your project to the GitHub repository. 

   we are adding  /node_modules ,/dist, /.parcel-cache 
   folders to .gitignore because we don't need this to push git,we can recreate this files if we have package.json & package-lock.json files.
   
   we are not adding the package.json & package-lock.json these 2 files to .gitignore,without these files we are unable to receate /node_modules ,/dist, /.parcel-cache .
   
9) what is difference between package.json & package-lock.json?
   package.json
       It is a metadata file that describes the project's dependencies, scripts, configuration, and other details.
   package-lock.json
       It is a lockfile that provides an exact, deterministic list of all the installed packages and their dependencies, including their exact version numbers.

10) why should i not modify package-lock.json?
   You should not modify package-lock.json unless you are updating the required packages.

11) what is node_modules? it is good idea to push that on git?
   The node_modules folder is a folder that is created when you install packages using the Node Package Manager (npm).
    It stores the packages and their dependencies that your project requires.

    It is generally not a good idea to push the node_modules folder to git because it can be very large and can change frequently. 

12) what is dist folder?
   The dist folder in React is a production-ready build of your application. It contains the minified and bundled code,
    as well as any assets that were used in the build process. The dist folder is typically created by running the npm run build command.

    The dist folder is typically used when you are ready to deploy your application to a production server. It is also useful for testing your application in a production-like environment.

 13) what is browserlists read about different bundlers : parcel ,webpack ,vite ?
     Browserslist is a tool that allows developers to specify which browsers they want their web application to support.
      It does this by using a configuration file that lists the browsers and versions that the application needs to support. 
      Browserslist is used by many different tools, including Autoprefixer, Babel, ESLint, PostCSS, SWC, and Webpack.

   Parcel is a web application bundler that is fast and easy to use. It does not require a configuration file, and 
   it can bundle JavaScript, CSS, and HTML files. Parcel also supports hot reloading, which makes it easy to develop and 
   debug web applications.

   Webpack is a module bundler that can be used to bundle JavaScript files for usage in a browser. It is more complex to use than 
   Parcel, but it offers more features and flexibility. Webpack can be used to bundle JavaScript modules, transpile code, 
   and optimize bundles for different browsers.

   Vite is a next-generation frontend tool that provides a lightning-fast dev server, bundling, and resolves the server cold start issue. 
   It is similar to Parcel in that it does not require a configuration file and it can bundle JavaScript, CSS, and HTML files. 
   However, Vite is faster than Parcel and it offers some additional features, such as native HMR support and built-in code splitting.

  14) Caret (^) and Tilde (~)?

     the tilde () allows updates to the patch version of a package, 
     while the caret (^) allows updates to the minor and patch versions of a package, while keeping the major version fixed 

   =========================================
   Episode 3:

1)What is JSX?
A: JSX stands for JavaScript XML. JSX allows us to write HTML elements in JavaScript and place them in the DOM without any createElement() and/or appendChild() methods. JSX makes it easier to write and add HTML in React. JSX converts HTML tags into react elements.

Example 1 using JSX:
const myElement = <h1>I Love JSX!</h1>;
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(myElement);

Example 2 Without JSX:
const myElement = React.createElement('h1', {}, 'I do not use JSX!');
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(myElement);

2) Superpowers of JSX.
A: Using JSX, you can write markup inside Javascript, providing you with a superpower to write logic and markup of a component inside a single .jsx file. JSX is easy to maintain and debug.

Example
function greeting(user) {
//JSX
  return <h1>{user}, How are you!!!</h1>;
}
3) Role of type attribute in script tag? What options can I use there?
A: The type attribute specifies the type of the script. The type attribute identifies the content between the <script> and </script> tags. It has a Default value which is “text/javascript”.

type attribute can be of the following types:
text/javascript : It is the basic standard of writing javascript code inside the <script> tag.

Syntax
<script type="text/javascript"></script>

text/ecmascript : this value indicates that the script is following the EcmaScript standards.
module: This value tells the browser that the script is a module that can import or export other files or modules inside it.
text/babel : This value indicates that the script is a babel type and required bable to transpile it.
text/typescript: As the name suggest the script is written in TypeScript.

4) {TitleComponent} vs {<TitleComponent/>} vs {<TitleComponent></TitleComponent>} in JSX.
A: The Difference is stated below:

{TitleComponent}: This value describes the TitleComponent as a javascript expression or a variable. The {} can embed a javascript expression or a variable inside it.
<TitleComponent/> : This value represents a Component that is basically returning Some JSX value. In simple terms TitleComponent a function that is returning a JSX value. A component is written inside the {<  />} expression.
<TitleComponent></TitleComponent> : <TitleComponent /> and <TitleComponent></TitleComponent> are equivalent only when < TitleComponent /> has no child components. The opening and closing tags are created to include the child components.
Example
<TitleComponent>
    <FirstChildComponent />
    <SecondChildComponent />
    <ThirdChildComponent />
</TitleComponent>

======================================
Episode 4:

1) Is JSX mandatory for React?
A: JSX is an Extension Syntax that allows writing HTML and Javascript together easily in React and is used to create React elements.
 These elements are then rendered to the React DOM. Each JSX element is just to make use of React easy and for calling React.
 createElement(component, props, …children) with less work. So, anything that is done with JSX can also be done with just plain JavaScript. 
 So JSX is not mandatory but is used for writing better and clean code instead of writing code using React.CreateElement.

Example of JSX
const sample = <h2>Greetings</h2>;

2) Is ES6 mandatory for React?
A: ES6 is not mandatory for React but is highly recommendable. The latest projects created on React rely a lot on ES6. 
React uses ES6, and you should be familiar with some of the new features like: Classes, Arrow Functions, Variables(let, const). 
ES6 stands for ECMAScript 6. ECMAScript was created to standardize JavaScript, and ES6 is the 6th version of ECMAScript, 
it was published in 2015.

3) {TitleComponent} vs {<TitleComponent/>} vs {<TitleComponent></TitleComponent>} in JSX.
A: The Difference is stated below:

{TitleComponent}: This value describes the TitleComponent as a javascript expression or a variable or React element. 
The {} can embed a javascript expression or a variable or React element inside it.

<TitleComponent/> : This value represents a Component that is basically returning Some JSX value. 
In simple terms TitleComponent a function that is returning a JSX value. If component is written inside the {<  />} expression.

<TitleComponent></TitleComponent> :
 <TitleComponent /> and <TitleComponent></TitleComponent> are equivalent only when < TitleComponent /> has no child components. 
 The opening and closing tags are created to include the child components.

Example
<TitleComponent>
    <FirstChildComponent />
    <SecondChildComponent />
    <ThirdChildComponent />
</TitleComponent>

4) How can I write comments in JSX?
A: JSX comments are written as follows:

{/*  */} - for single or multiline comments
Example
{/* A JSX comment */}
{/* 
  Multi
  line
  JSX
  comment
*/}  

5) What is <React.Fragment></React.Fragment> and <></>?
A: <React.Fragment></React.Fragment> is a feature in React that allows you to return multiple elements from a React component 
by allowing you to group a list of children without adding extra nodes to the DOM. <></> is the shorthand tag for React.Fragment.
 The only difference between them is that the shorthand version does not support the key attribute.

Example
return (
        <React.Fragment>
            <Header />
            <Navigation />
            <Main />
            <Footer />
        </React.Fragment>
    );

return (
        <>
            <Header />
            <Navigation />
            <Main />
            <Footer />
        </>
    );

6) What is Reconciliation in React?
A: Reconciliation is the process through which React updates the Browser DOM and makes React work faster. 
React use a diffing algorithm so that component updates are predictable and faster. React would first calculate the 
difference between the real DOM and the copy of DOM (Virtual DOM) when there's an update of components. React stores a 
copy of Browser DOM which is called Virtual DOM. When we make changes or add data, React creates a new Virtual DOM and compares it with the previous one.
 Comparison is done by Diffing Algorithm. React compares the Virtual DOM with Real DOM. It finds out the changed nodes and updates only the changed 
 nodes in Real DOM leaving the rest nodes as it is. This process is called Reconciliation.

7) What is React Fiber?
A: React Fiber is a concept of ReactJS that is used to render a system faster, smoother and smarter. The Fiber reconciler, 
which became the default reconciler for React 16 and above, is a complete rewrite of React’s reconciliation algorithm to solve some long-standing issues in React. 
Because Fiber is asynchronous, React can:

Pause, resume, and restart rendering work on components as new updates come in
Reuse previously completed work and even abort it if not needed
Split work into chunks and prioritize tasks based on importance

8) Why do we need keys in React?
A: A key is a special attribute you need to include when creating lists of elements in React.
 Keys are used in React to identify which items in the list are changed, updated, or deleted. In other words, 
 we can say that keys are unique Identifier used to give an identity to the elements in the lists. Keys should be given 
 to the elements within the array to give the elements a stable identity.

Example
<li key={0}>1</li>
<li key={1}>2</li>
<li key={2}>3</li>

9) Can we use index as keys in React?
A: Yes, we can use the index as keys, but it is not considered as a good practice to use them because if the order of 
items may change. This can negatively impact performance and may cause issues with component state. 
Keys are taken from each object which is being rendered. There might be a possibility that if we modify the incoming data react 
may render them in unusual order.

10) What is props in React? Ways to.
A: props stands for properties. Props are arguments passed into React components. props are used in React to pass data from 
one component to another (from a parent component to a child component(s)). They are useful when you want the flow of data in 
your app to be dynamic.

Example
function App() {
  return (
    <div className="App">
      <Tool name="Chetan Nada" tool="Figma"/> // name and tool are props
    </div>
  )
}

11) What is Config Driven UI?
A: Config Driven UI are based on the configurations of the data application receives. It is rather a good practice to use 
config driven UIs to make application for dynamic. It is a very common & basic approach to interact with the User. 
It provides a generic interface to develop things which help your project scale well. It saves a lot of development time and 
effort. A typical login form, common in most of the Apps. Most of these forms also get frequent updates as the requirements 
increase in terms of Form Validations, dropdown options,.. or design changes.

12) Difference between Virtual DOM and Real DOM?
A: DOM stands for Document Object Model, which represents your application UI and whenever the changes are made in the application, 
this DOM gets updated and the user is able to visualize the changes. DOM is an interface that allows scripts to update the content, 
style, and structure of the document.

Virtual DOM:
The Virtual DOM is a light-weight abstraction of the DOM. You can think of it as a copy of the DOM, that can be updated without affecting the actual DOM. 
It has all the same properties as the real DOM object, but doesn’t have the ability to write to the screen like the real DOM.
Virtual DOM is just like a blueprint of a machine, can do the changes in the blueprint but those changes will not directly apply to the machine.
Reconciliation is a process to compare and keep in sync the two files (Real and Virtual DOM). Diffing algorithm is a technique of reconciliation which is used by React.

Real DOM:
The DOM represents the web page often called a document with a logical tree and each branch of the tree ends in a node and each node contains object 
programmers can modify the content of the document using a scripting language like javascript and the changes and updates to the dom are fast because of 
its tree-like structure but after changes, the updated element and its children have to be re-rendered to update the application UI so the re-rendering of the 
UI which make the dom slow all the UI components you need to be rendered for every dom update so real dom would render the entire list and not only those item that receives the update .

         Real DOM	                                                  Virtual DOM
DOM manipulation is very expensive	                              DOM manipulation is very easy
There is too much memory wastage	                                 No memory wastage
It updates Slow	                                                It updates fast
It can directly update HTML	                                    It can’t update HTML directly
Creates a new DOM if the element updates.	                        Update the JSX if the element update
It allows us to directly target any specific node (HTML element)	It can produce about 200,000 Virtual DOM Nodes / Second.
It represents the UI of your application	                        It is only a virtual representation of the DOM

==========================================================
Episode 5:

1) What is the difference between Named export, Default export, and * as export?

  Default exports are used to export a single "main" value from a module, while named exports allow us to export multiple values 
  with specific names. Default exports allow us to import the exported value with any name in the importing module,
   while named exports require us to use the exact exported names when importing.

2) What is the importance of config.js file?
  Config. js allows developers to configure their applications in an XML block instead of hard-coding values inside their scripts or in JSON objects.

3) What are React Hooks?

React Hooks are simple JavaScript functions that we can use to isolate the reusable part from a functional component.

4) Why do we need useState Hook?
  The React useState Hook allows you to have state variables in functional components. You pass the initial state to this function, and 
  it returns a variable with the current state value (not necessarily the initial state) and another function to update this value.


.overflow-text{
    text-overflow:ellipsis ;
    width: 200px; 
    overflow: hidden;height: 20px;
}

============================================================
Episode 6:

 1) What is Microservice?
A: Microservice - also known as the microservice architecture - is an architectural and organizational approach to software development 
where software is composed of small independent services like database, server or a UI of the application, that communicate over well-defined APIs.
 These services are owned by small, self-contained teams. Microservices architectures make applications easier to scale and faster to develop, 
 enabling innovation and accelerating time-to-market for new features. means we are dividing software into small, well-defined modules enables teams to use functions for multiple purposes.

Benefits of Microservices:
Flexible Scaling
Easy Deployment
Technological Freedom
Reusable Code
Resilience

2) What is Monolith architecture?
A: A Monolith architecture is a traditional model of a software program, which is built as a unified unit that is self-contained and independent from other applications. 
A monolithic architecture is a singular, large computing network with one code base that couples all of the business concerns together.
 To make a change to this sort of application requires updating the entire stack by accessing the code base and building and deploying an updated version of the service-side interface.
  This makes updates restrictive and time-consuming. means we are not dividing software into small, well-defined modules, we use every services like, database, server or a UI of the application, in one Application file.

3) What is the difference between Monolith and Microservice?
A: With monolithic architectures, all processes are tightly coupled and run as a single service. This means that if one process of the application experiences a spike in demand, the entire architecture must be scaled. Adding or improving a monolithic application’s features becomes more complex as the code base grows. This complexity limits experimentation and makes it difficult to implement new ideas. Monolithic architectures add risk for application availability because many dependent and tightly coupled processes increase the impact of a single process failure.

With a microservices architecture, an application is built as independent components that run each application process as a service. These services communicate via a well-defined interface using lightweight APIs. Services are built for business capabilities and each service performs a single function. Because they are independently run, each service can be updated, deployed, and scaled to meet demand for specific functions of an application. Monolith and Microservice

4) Why do we need a useEffect Hook?
A: useEffect Hook is javascript function provided by react. The useEffect Hook allows you to eliminate side effects in your components. 
Some examples of side effects are: fetching API data, directly updating the DOM, and setting up subscriptions or timers, etc can be lead to unwarranted side-effects. useEffect accepts two arguments, a callback function and a dependency array. The second argument is optional.

useEffect(() => {}, [])
The () => {} is callback function and [] is called a empty dependency array. If anything that we pass (suppose currentState) inside the [] it trigger the callback function and changes the state of the application.

useEffect(() => {
    setCurrentState("true");
}, [currentState])
If we do not pass empty dependency array then the useEffect runs everytime when the UI is rendered.

useEffect(() => {})

5) What is Optional Chaining?
A: Optional Chaining (?.) operator accesses an object's property or calls a function. If the object accessed or function called is undefined or null , it returns undefined instead of throwing an error. Optional Chaining (?.) is good way of accessing the object keys, it prevents the application from being crashed if the key that we are trying to access is not present. If the key is not present then instead of a throwing key error, it returns undefined.

6) What is Shimmer UI?
A: A Shimmer UI resembles the page's actual UI, so users will understand how quickly the web or mobile app will load even before the content has shown up. It gives people an idea of what's about to come and what's happening (while UI currently loading) when a page full of content/data takes more than 3 - 5 seconds to load. Shimmer UI is a great way for loading the applications. Instead of showing a loading circle we can design a shimmer UI for our application that is good for user experience.

7) What is the difference between JS expression and JS statement?
A: A JS expression returns a value that we use in the application. for example:

1 + 2 // expresses 
"foo".toUpperCase() // expresses 'FOO'
console.log(2) // logs '2'
isTrue ? true : false // returns us a true or false value based on isTrue value
A JS statement, does not return a value. for example:

let x; // variable declaration
if () { } // if condition
If we want to use JS expression in JSX, we have to wrap in {/* expression slot */} and if we want to use JS statement in JSX, we have to wrap in {(/* statement slot */)};

8) What is Conditional Rendering? explain with a code example.
A: Conditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like if or the conditional operator to create elements representing the current state, and let React update the UI to match them. for example:

// Using Ternary operator as a shorthand way or writing an if-else statement
{isLoggedIn ? (return <UserGreeting />) : (return <GuestGreeting />)};
// Using an if…else Statement
{
  (if (isLoggedIn) {
    return <UserGreeting />;
  }else {
    return <GuestGreeting />;
  })
}
// Using Logical &&
{isLoggedIn && <button>Logout</button>}

9) What is CORS?
A: Cross-Origin Resource Sharing (CORS) is an HTTP-header based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources. CORS defines a way in which a browser and server can interact to determine whether it is safe to allow the cross-origin request.

10) What is async and await?
A: Async: It simply allows us to write promises-based code as if it was synchronous and it checks that we are not breaking the execution thread. It operates asynchronously via the event loop. Async functions will always return a promise. It makes sure that a promise is returned and if it is not returned then JavaScript automatically wraps it in a promise which is resolved with its value. Await: Await function is used to wait for the promise. It could be used within the async block only. It makes the code wait until the promise returns a result. It only makes the async block wait. for example:

// async function getRestaurant to fetch Swiggy API data
  async function getRestaurants() {
    const data = await fetch("Swiggy_API_URL");
    const json = await data.json();
    // we get the Swiggy API data in json format
    console.log(json);
  }

11) What is the use of const json = await data.json(); in getRestaurants()?
A: The data object, returned by the await fetch(), is a generic placeholder for multiple data formats.
 so we can extract the JSON object from a fetch response by using await data.json(). data.json() is a method on the 
 data object that lets you extract a JSON object from the data or response. The method returns a promise because we have used
  await keyword. so data.json() returns a promise resolved to a JSON object.

  ===============================
  Episode : 7

  1) What are various ways to add images into our App? Explain with code examples.
A: Using the full URL of the image for the web (CDN) or any public images. Example :

<img src="https://reactjs.org/logo-og.png" alt="React Image" />
Adding the image into the project Drag your image into your project and import it into the desired component

import reactLogo from "./reactLogo.png";
export default function App() {
  return <img src={reactLogo} alt="react logo" />
}
The correct way to structure images in your project is to add them in an images folder. 
If you are using other assets than just images, you might want to add all in the assets folders.

import reactLogo from "../../assets/images/reactLogo.png";
export default function App() {
  return <img src={reactLogo} alt="react logo" />
}
2) What would happen if we do console.log(useState())?
A: If we do console.log(useState()), we get an array [undefined, function] where first item in an array is state is undefined 
and the second item in an array is setState function is bound dispatchSetState.

3) How will useEffect behave if we don't add a dependency array?
A: Syntax of useEffect is:

useEffect(() => {}, []);
Case 1 : When the dependency array is not included in the arguments of useEffect() hook, the callback function will be executed 
every time the component is rendered and re-rendered.

useEffect(() => {
	console.log("I run everytime this component rerenders")
});
Case 2 : When the dependency array is empty in the arguments of useEffect() hook, the callback function will be executed only one 
time during the initial render of the component.

useEffect(() => {
	console.log("I Only run once (When the component gets mounted)")
}, []);
Case 3 : When the dependency array contains a condition, the callback function will be executed one time during the initial 
render of the component and also rerender if there is a change in the condition.

useEffect(() => {
	console.log("I run every-time when my condition changed")
}, [condition]);

4) What is SPA?
A: Single Page Application (SPA) is a web application that dynamically updates the webpage with data from web server without 
reloading/refreshing the entire page. All the HTML, CSS, JS are retrieved in the initial load and other data/resources can be loaded 
dynamically whenever required. An SPA is sometimes referred to as a single-page interface (SPI).

5) What is the difference between Client Side Routing and Server Side Routing?
A: In Server-side routing or rendering (SSR), every change in URL, http request is made to server to fetch the webpage, and 
replace the current webpage with the older one.

In Client-side routing or rendering (CSR), during the first load, the webapp is loaded from server to client, after which whenever 
there is a change in URL, the router library navigates the user to the new page without sending any request to backend. 
All Single Page Applications uses client-side routing.

